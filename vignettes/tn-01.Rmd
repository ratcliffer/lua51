---
title: "Technical Note 01"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Technical Note 01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

## Lua sources

Download and verify the Lua 5.1.5 sources. The shell provides tools for this, but R directly lets you handle file downloads and `tar` balls. The following excerpt requires the `openssl` package in order to check the digest.
```{r tar-gz, eval=FALSE}
tar.gz <- tempfile(fileext = ".tar.gz")
download.file("https://www.lua.org/ftp/lua-5.1.5.tar.gz", tar.gz)
sha.256 <- as.character(openssl::sha256(file(tar.gz, raw = TRUE)))
stopifnot(sha.256 == "2640fc56a795f29d28ef15e13c34a47e223960b0240e8cb0a82d9b0738695333")
untar(tar.gz, list = TRUE)
```
Select _only_ the C and C header sources. Requires `xfun` package.
```{r file-ext-c-h, eval=FALSE}
files <- untar(tar.gz, list = TRUE)
files[xfun::file_ext(files) %in% c("c", "h")]
#>  [1] "lua-5.1.5/etc/all.c"      "lua-5.1.5/etc/min.c"      "lua-5.1.5/etc/noparser.c"
#>  [4] "lua-5.1.5/src/loadlib.c"  "lua-5.1.5/src/ldo.c"      "lua-5.1.5/src/ltable.c"
#>  [7] "lua-5.1.5/src/linit.c"    "lua-5.1.5/src/lobject.h"  "lua-5.1.5/src/ltable.h"
#> [10] "lua-5.1.5/src/lzio.c"     "lua-5.1.5/src/luaconf.h"  "lua-5.1.5/src/lfunc.h"
#> [13] "lua-5.1.5/src/lfunc.c"    "lua-5.1.5/src/lopcodes.h" "lua-5.1.5/src/loslib.c"
#> [16] "lua-5.1.5/src/lundump.c"  "lua-5.1.5/src/lvm.h"      "lua-5.1.5/src/lundump.h"
#> [19] "lua-5.1.5/src/lstate.h"   "lua-5.1.5/src/ltm.c"      "lua-5.1.5/src/lbaselib.c"
#> [22] "lua-5.1.5/src/lapi.h"     "lua-5.1.5/src/ldump.c"    "lua-5.1.5/src/lauxlib.c"
#> [25] "lua-5.1.5/src/lcode.h"    "lua-5.1.5/src/lparser.h"  "lua-5.1.5/src/ldebug.c"
#> [28] "lua-5.1.5/src/ldblib.c"   "lua-5.1.5/src/lua.c"      "lua-5.1.5/src/lgc.h"
#> [31] "lua-5.1.5/src/lapi.c"     "lua-5.1.5/src/liolib.c"   "lua-5.1.5/src/lua.h"
#> [34] "lua-5.1.5/src/ldebug.h"   "lua-5.1.5/src/lmem.c"     "lua-5.1.5/src/lstate.c"
#> [37] "lua-5.1.5/src/lobject.c"  "lua-5.1.5/src/lparser.c"  "lua-5.1.5/src/llimits.h"
#> [40] "lua-5.1.5/src/lzio.h"     "lua-5.1.5/src/ldo.h"      "lua-5.1.5/src/lmathlib.c"
#> [43] "lua-5.1.5/src/lauxlib.h"  "lua-5.1.5/src/ltm.h"      "lua-5.1.5/src/print.c"
#> [46] "lua-5.1.5/src/llex.h"     "lua-5.1.5/src/ltablib.c"  "lua-5.1.5/src/lmem.h"
#> [49] "lua-5.1.5/src/lvm.c"      "lua-5.1.5/src/llex.c"     "lua-5.1.5/src/lstring.h"
#> [52] "lua-5.1.5/src/lgc.c"      "lua-5.1.5/src/lstrlib.c"  "lua-5.1.5/src/lcode.c"
#> [55] "lua-5.1.5/src/luac.c"     "lua-5.1.5/src/lstring.c"  "lua-5.1.5/src/lualib.h"
#> [58] "lua-5.1.5/src/lopcodes.c"
```
Embedded Lua does not require all these sources. Take `luac.c` and `lua.c` for example: respectively the Lua compiler command `main()` function and the same for the standalone interpreter. The `lua51` package replaces both.

## C compiler warnings

Compiling the Lua source code under R conditions succeeds but with some warnings. Two interesting ones caught by the compiler's `-Wmisleading-indentation` flag.

```
lauxlib.c:577:4:warning: is 'whileuse does not guard... [-Wmisleading-indentation]
       while ((c = getc(lf.f)) != EOF && c != LUA_SIGNATURE[0]) ;
       ^~~~~
lauxlib.c:578:5:note: .this statement, but the latter is misleadingly indented as if it were guarded by the 'while'
        lf.extraline = 0;
        ^~
ltablib.c:n function 'addfield':
   ltablib.c:137:3:warning: is 'ifuse does not guard... [-Wmisleading-indentation]
      if (!lua_isstring(L, -1))
      ^~
   ltablib.c:140:5:note: .this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
        luaL_addvalue(b);
        ^~~~~~~~~~~~~
```

## R CMD check warnings

Running `devtools::check()` initially gives warnings. The check complains about `print.c` because it calls C standard-library `printf`. Most of the functions are static implementations of Lua types to `printf`. Useful for learning how to render Lua types, but not needed for an embedded Lua; R will supply the printing.

Other complaints arise from calling C `rand`, `srand` and `exit`. In other
words, Lua invokes C's pseudo-random number generator and exits on a panic.
Checking issues the summary statement, "Compiled code should not call entry
points which might terminate R nor write to `stdout`/`stderr` instead of to the
console, nor use Fortran I/O nor system RNGs." This implies that the basic Lua source needs modification to interoperate with R rather than the lower-level C standard library. Quite expected.

### Replacing random number generator
Typically, the standard library declares its pseudo-random number generator in `stdlib.h` as follows.
```c
  int __cdecl rand(void);
  void __cdecl srand(unsigned int _Seed);
```
Lua invokes these randomising functions as part of its maths library, `lmathlib.c` source.
```c
  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
```
Manifest constant `RAND_MAX` expands to `0x7fff`.

Lines 209 through 212.
```c
static int math_randomseed (lua_State *L) {
  srand(luaL_checkint(L, 1));
  return 0;
}
```
Lua integers are `ptrdiff_t` types, or `__int64` on 64-bit machines.

## Getting lines

Lua sources use the `getline` symbol for a debug macro. It clashes with [`getline`][getline.3] on macOS and Linux, having three arguments rather than two.

[getline.3]:https://www.man7.org/linux/man-pages/man3/getline.3.html
